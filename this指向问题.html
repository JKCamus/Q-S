<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>this指向</title>
</head>

<body>
    <script>
        /*！ section1 */
        // 简单的this指向
        // var name = '卡卡';
        // var cat = {
        //     name: '有鱼',
        //     eat: function () {
        //         console.log(this);//指向cat本身
        //         console.log(this.name); //有鱼
        //     }
        // }
        //cat.eat();

        /* 对象方法,单层时，指向该对象，多层作用域链时，this指的是距离方法最近的一层对象 */
        // var name = '卡卡';
        // var cat = {
        //     name: '有鱼',
        //     eat1: {
        //         name: '年年',
        //         eat2: function () {
        //             console.log(this); //
        //             console.log(this.name); //年年
        //         }
        //     }
        // }
        // cat.eat1.eat2(); //年年 this指向eat1

        // /* 这里就是很大的坑，这个是因为经过赋值操作时，并未发起函数调用，eat3()这个才是真正的调用，而发起这个调用的是根对象window，所以this指的就是window，this.name=卡卡 */
        // var eat3 = cat.eat1.eat2;
        // eat3() //卡卡

        // /* 这样又是指向eat1 ，因为在调用后赋值的*/
        // var eat4 = cat.eat1.eat2();
        // eat4 //年年

        /* section2 构造函数 this指向*/
        // var name = '卡卡';

        // function Cat() {
        //     this.name = '有鱼';
        //     this.type = '英短蓝猫';
        //     console.log(this);

        // }
        // var cat1 = new Cat();

        // console.log(cat1); // 实例化新对象 Cat {name: "有鱼", type: "英短蓝猫"}
        // console.log(cat1.name); // 有鱼

        // apply bind call修改this指向
        var name = '有鱼';

        function eat() {
            console.log(this.name);
        }
        var cat = {
            name: '年年',
        }
        var dog = {
            name: '高飞',
        }
        // apply方法和call方法相当于改变了显式的修改了prototype原型
        eat.call(cat); // 年年
        eat.call(dog); // 高飞

        eat.apply(cat)
    </script>

</body>

</html>